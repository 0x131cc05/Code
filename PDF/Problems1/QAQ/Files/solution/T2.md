**子任务1**

按照题意模拟

**子任务2**

不要求强制在线，可以将询问离线之后把最后的树建出来

大树每个节点上的数都是固定的。对于3操作倍增，对于4操作树状数组即可

**子任务3**

使用LCT，需要支持link，路径和以及子树和

子任务4，6是子任务5，7的离线版本，这里不做讨论

**子任务5**

将大树上的每一棵模板树抽象成一个点，与其父亲的连边的边权相当于当前模板树的根到它所挂的节点的路径长度

这样相当于每次加一个叶子、求路径和

对于缩点之后的大树以及模板树分别讨论

需要支持链加、查询历史版本的链和，使用主席树树剖

**子任务7**

继续沿用子任务5的思路，将大树抽象成若干个点

对于大树上的每一棵模板树，我们为其新建一个splay，这个splay按照dfs序维护所有挂在这棵模板树下的其它模板树的边权之和

这样我们只需要在4操作对应的那棵模板树上查splay的区间和即可

考虑如何维护这个splay里面的每个元素

如果大树是静态的，那么我们可以对大树进行轻重链剖分，对于重儿子维护标记，对于轻儿子暴力下放标记

具体来说，每次我们往大树上挂一棵模板树的时候，类似树剖的方法不停地跳重链，对于每条链维护一个标记表示这条链上每个点的重儿子还应该加多少

注意这里我们只能对链上深度小于等于当前点的点加标记

进行4操作的时候，我们将当前点还未下放的标记下放，再查询splay中的区间和即可

由于有强制在线，因此需要用LCT维护轻重链的切换以及每一条链上的标记。每加入一个点的时候我们就尝试access，但是只对需要切换的轻重链交换儿子，同时下放标记

**子任务8**

结合子任务5,7

